#!/usr/bin/env python3

import argparse
import os
import pathlib
import platform
import shutil
import subprocess
import sys


def is_linux():
    return platform.system() == 'Linux'


def is_macos():
    return platform.system() == 'Darwin'


def is_windows():
    return platform.system() == 'Windows'


def printf(*args, **kwargs):
    excludes_env = {key: kwargs[key] for key in kwargs if key not in ['env']}
    if excludes_env:
        print(*args, excludes_env)
    else:
        print(*args)
    sys.stdout.flush()


def run(cmd, **kwargs):
    printf(cmd, **kwargs)
    subprocess.run(cmd, **kwargs)


class Configure:
    def __init__(self, args):
        conda = shutil.which('mamba')
        if not conda:
            conda = shutil.which('conda')
            if not conda:
                print('Please install conda.')
                print('See: https://docs.conda.io/projects/conda/en/latest/user-guide/install')
                sys.exit(1)
        self.args = args
        self.conda = pathlib.Path(conda)
        self.this_dir = pathlib.Path(__file__).absolute().parent
        self.cenv_dir = (args.temp_dir if args.temp_dir else self.this_dir) / '.cenv'
        self.build_dir = (pathlib.Path(f'{args.build_prefix}') / f'build-{args.target}' / args.type).resolve()
        print('conda found at: {}'.format(self.conda))

        if args.ci:
            self.configure_cmake()
        else:
            if not self.is_activated():
                self.configure_conda()
                self.activate_conda()
            else:
                if not args.skip_precommit:
                    self.configure_precommit()
                self.configure_cmake()

            print()
            print("Your build is configured.")
            print()
            print("1) Build PlaidML:")
            print(f"   $ ninja -C {self.build_dir}")
            print()
            print("2) Install built packages:")
            print(f"   $ pip install -U {self.build_dir}/*.whl")
            print()
            print("3) Setup a device:")
            print(f"   $ ninja -C {self.build_dir} setup")
            print("   non-interactively:")
            print("   $ export PLAIDML_DEVICE_IDS=llvm_cpu.0")
            print("   $ export PLAIDML_EXPERIMENTAL=1")
            print()
            print("4) Run all unit tests:")
            print(f"   $ ninja -C {self.build_dir} check-smoke")
            print()
            print("5) Build plaidbench:")
            print(f"   $ ninja -C {self.build_dir} plaidbench_py")
            print()


    def is_activated(self):
        return os.getenv('CONDA_PREFIX') == str(self.cenv_dir)

    def activate_conda(self):
        printf('Activating conda environment')
        env = os.environ.copy()
        env['SKIP_BOOTSTRAP'] = '1'
        cmd = [
            self.conda,
            'run',
            '--no-capture-output',
            '-p',
            self.cenv_dir,
            'python',
        ] + sys.argv
        run(cmd, check=True, env=env)

    def configure_conda(self):
        if is_windows():
            env_file = self.this_dir / 'environment-windows.yml'
        else:
            env_file = self.this_dir / 'environment.yml'

        if self.cenv_dir.exists():
            if not self.args.skip_conda_update:
                print('Updating conda environment from: {}'.format(env_file))
                cmd = [
                    str(self.conda),
                    'env',
                    'update',
                    '-f',
                    str(env_file),
                    '-p',
                    str(self.cenv_dir),
                    '--prune',
                ]
                run(cmd, check=True, stdout=subprocess.DEVNULL)
        elif not self.args.skip_conda_env:
            print('Creating conda environment from: {}'.format(env_file))
            cmd = [
                str(self.conda),
                'env',
                'create',
                '-f',
                str(env_file),
                '-p',
                str(self.cenv_dir),
            ]
            run(cmd, check=True, stdout=subprocess.DEVNULL)

    def configure_precommit(self):
        if is_windows():
            search_path = self.cenv_dir / 'Scripts'
        else:
            search_path = self.cenv_dir / 'bin'
        print()
        print('Searching for pre-commit in: {}'.format(search_path))
        pre_commit = shutil.which('pre-commit', path=str(search_path))
        if not pre_commit:
            print('pre-commit could not be found.')
            print('Is your conda environment created and up to date?')
            sys.exit(1)
        run([pre_commit, 'install'], check=True)

    def configure_compiler(self):
        cmake_compiler_flags = []

        cc = self.args.cc
        if cc is None:
            cc = os.getenv('CC').split(' ', 1)
        cxx = self.args.cxx
        if cxx is None:
            cxx = os.getenv('CXX').split(' ', 1)

        if cc:
            cmake_compiler_flags.append(f'-DCMAKE_C_COMPILER={cc[0]}')
            if 'clang' in os.path.basename(cc[0]):
                if 2 == len(cc):
                    toolchain = cc[1].split('=', 1)
                    if '--gcc-toolchain' == toolchain[0] and 2 == len(toolchain):
                        cmake_compiler_flags.append(f'-DCMAKE_C_COMPILER_EXTERNAL_TOOLCHAIN={toolchain[1]}')
        if cxx:
            cmake_compiler_flags.append(f'-DCMAKE_CXX_COMPILER={cxx[0]}')
            if 'clang++' in os.path.basename(cxx[0]):
                #cmake_compiler_flags.append('-DCMAKE_CXX_FLAGS=-w')
                if 2 == len(cxx):
                    toolchain = cxx[1].split('=', 1)
                    if '--gcc-toolchain' == toolchain[0] and 2 == len(toolchain):
                        cmake_compiler_flags.append(f'-DCMAKE_CXX_COMPILER_EXTERNAL_TOOLCHAIN={toolchain[1]}')

        if self.args.cxx_std:
            cmake_compiler_flags.append(f'-DCMAKE_CXX_STANDARD={self.args.cxx_std}')

        if self.args.ld:
            cmake_compiler_flags.append(f'-DLLVM_USE_LINKER={self.args.ld}')

        return cmake_compiler_flags

    def configure_cmake(self):
        cmd = [
            'cmake',
            '-S.',
            f'-B{self.build_dir}',
            '-GNinja',
            '-Wno-dev',
            f'-DCMAKE_BUILD_TYPE={self.args.type}',
            '-DFETCHCONTENT_QUIET=OFF',
            '-DPML_OPENVINO_BRIDGE=OFF',
        ]
        if self.args.temp_dir:
            fc_dir = self.args.temp_dir / f'fc-{self.args.target}'
            cmd.append(f'-DFETCHCONTENT_BASE_DIR={fc_dir}')
        if self.args.local_llvm:
            cmd.append(f'-DLOCAL_LLVM_DIR={self.args.local_llvm}')
        else:
            cmd.append('-ULOCAL_LLVM_DIR')
        if self.args.launcher and '.' != str(self.args.launcher):
            cmd.append(f'-DCMAKE_CXX_COMPILER_LAUNCHER={self.args.launcher}')
            cmd.append(f'-DCMAKE_C_COMPILER_LAUNCHER={self.args.launcher}')
        cmd.extend(self.configure_compiler())
        run(cmd, check=True)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--ci', action='store_true', help='Enable CI mode')
    parser.add_argument('--skip_conda_update',
                        action='store_true',
                        help='Skip updating the conda environment.')
    parser.add_argument('--skip_conda_env',
                        action='store_true',
                        help='Skip the conda environment creation step.')
    parser.add_argument('--skip_precommit',
                        action='store_true',
                        help='Skip the precommit configuration step.')
    parser.add_argument('--local_llvm', help='Configure LOCAL_LLVML_DIR', type=pathlib.Path)
    parser.add_argument('--type',
                        choices=['Debug', 'Release', 'RelWithDebInfo'],
                        default='Release',
                        help='Configures CMAKE_BUILD_TYPE')
    parser.add_argument('--target',
                        choices=['aarch64', 'x86_64'],
                        default='x86_64',
                        help='set the target')
    parser.add_argument('--build-prefix',
                        type=pathlib.Path,
                        help='Configures a prefix for an absolute build directory.')
    parser.add_argument('--temp-dir',
                        type=pathlib.Path,
                        help='Configures a temporary directory for cached assets.')
    parser.add_argument('--launcher',
                        type=pathlib.Path,
                        default='ccache',
                        help='Path/name of a compiler launcher.')
    parser.add_argument('--cc',
                        type=pathlib.Path,
                        help='Path/name of the C compiler.')
    parser.add_argument('--cxx',
                        type=pathlib.Path,
                        help='Path/name of the C++ compiler.')
    parser.add_argument('--cxx-std',
                        type=int,
                        help='C++ standard version, e.g., 20.')
    parser.add_argument('--ld',
                        type=pathlib.Path,
                        help='Path/name of the linker.')
    args = parser.parse_args()

    print("Configuring PlaidML build environment")
    print(args)

    cfg = Configure(args)

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        pass
